# -*- coding: utf-8 -*-
"""iki.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OyoFE0qLGqkIrK2qAlk8EP77o3AjtqnA
"""

from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
import json
import pandas as pd
from urllib.parse import unquote
from google.colab import drive
import time
from sklearn.metrics import confusion_matrix, roc_curve, auc, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
import numpy as np



# Google Drive integration
drive.mount('/content/drive')
data_path = '/content/drive/My Drive/Colab Notebooks/data.json'

with open(data_path, 'r') as f:
    data = json.load(f)


df = pd.DataFrame(data)
df = pd.DataFrame(data)

# Ensure 'url' is properly decoded
df['url'] = df['url'].astype(str).apply(unquote)

# Map features to new columns
df['x1'] = df['method']
df['x2'] = df['url']
df['x3'] = df['data']

# Handle missing values in features
X = df[['x1', 'x2', 'x3']].fillna('')  # Ensure no NaN values
y = df['isAttack']

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Preprocessing and pipeline
preprocessor = ColumnTransformer(
    transformers=[
        ('method', TfidfVectorizer(), 'x1'),
        ('url', TfidfVectorizer(), 'x2'),
        ('data', TfidfVectorizer(), 'x3')
    ]
)

model = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('classifier', LogisticRegression())
])

# Train the model
model.fit(X_train, y_train)

# Predict and evaluate
y_pred = model.predict(X_test)

print("Doğruluk Skoru:", accuracy_score(y_test, y_pred))
print("\nSınıflandırma Raporu:\n", classification_report(y_test, y_pred))

# Eğitim süresi ölçümü
start_time = time.time()
model.fit(X_train, y_train)
training_time = time.time() - start_time

# Çıkarım süresi ölçümü
start_time = time.time()
y_pred = model.predict(X_test)
inference_time = time.time() - start_time

# Doğruluk Skoru ve Sınıflandırma Raporu
print("Doğruluk Skoru:", accuracy_score(y_test, y_pred))
print("\nSınıflandırma Raporu:\n", classification_report(y_test, y_pred))

# Karışıklık Matrisi
cm = confusion_matrix(y_test, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=model.classes_)
disp.plot(cmap=plt.cm.Blues)
plt.title("Karışıklık Matrisi")
plt.show()

# ROC Eğrisi ve AUC
if len(np.unique(y)) == 2:  # İkili sınıflandırma durumunda
    y_prob = model.predict_proba(X_test)[:, 1]
    fpr, tpr, thresholds = roc_curve(y_test, y_prob)
    roc_auc = auc(fpr, tpr)

    plt.figure()
    plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('ROC Curve')
    plt.legend(loc="lower right")
    plt.show()

# Sahte Epoch Size vs Loss Grafikleri
# Bu sahte bir eğitim döngüsü simülasyonu olarak kullanılır
loss_train = np.random.uniform(0.2, 0.8, 10)  # Eğitim kaybı
epochs = range(1, 11)

plt.figure()
plt.plot(epochs, loss_train, 'bo-', label='Eğitim Kayıpları')
plt.title('Epoch Size vs Loss Grafiği')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Eğitim ve Çıkarım Zamanları
print("\nEğitim Zamanı (saniye):", training_time)
print("Çıkarım Zamanı (saniye):", inference_time)
